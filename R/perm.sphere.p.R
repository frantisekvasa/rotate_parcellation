# Function to generate a p-value for the spatial correlation between two parcellated cortical surface maps, 
# using a set of spherical permutations of regions of interest (which can be generated using the function "rotate_parcellation").
# The function performs the permutation in both directions; i.e.: by permute both measures, 
# before correlating each permuted measure to the unpermuted version of the other measure
#
# Inputs:
# x                 one of two maps to be correlated                                                                    vector
# y                 second of two maps to be correlated                                                                 vector
# perm_id           array of permutations, from set of regions to itself (as generated by "rotate_parcellation")        array of size [n(total regions) x nrot]
# corr_type         type of correlation                                                                                 "spearman" (default) or "pearson"
#
# Output:
# p_perm            permutation p-value
#
# Frantisek Vasa, fv247@cam.ac.uk, June 2017 - July 2018

perm.sphere.p = function(x,y,perm.id,corr.type='spearman') {
  
  nroi = dim(perm.id)[1]  # number of regions
  nperm = dim(perm.id)[2] # number of permutations
  
  rho.emp = cor(x,y,method=corr.type)  # empirical correlation
  
  # permutation of measures
  x.perm = y.perm = array(NA,dim=c(nroi,nperm))
  for (r in 1:nperm) {
    for (i in 1:nroi) {
      x.perm[i,r] = x[perm.id[i,r]]
      y.perm[i,r] = y[perm.id[i,r]]
    }
  }
  
  # correlation to unpermuted measures
  rho.null.xy = rho.null.yx = vector(length=nperm)
  for (r in 1:nperm) {
    rho.null.xy[r] = cor(x.perm[,r],y,method=corr.type)
    rho.null.yx[r] = cor(y.perm[,r],x,method=corr.type)
  }
  
  # p-value definition depends on the sign of the empirical correlation
  if (rho.emp>0) {
    p.perm.xy = sum(rho.null.xy>rho.emp)/nperm
    p.perm.yx = sum(rho.null.yx>rho.emp)/nperm
  } else { 
    p.perm.xy = sum(rho.null.xy<rho.emp)/nperm
    p.perm.yx = sum(rho.null.yx<rho.emp)/nperm
  } 

  # return average p-value
  return((p.perm.xy+p.perm.yx)/2)
    
}